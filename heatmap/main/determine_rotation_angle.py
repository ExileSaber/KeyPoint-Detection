import osimport jsonimport mathimport numpy as npfrom numpy.linalg import det# 判断三个点确认的圆的圆心和半径def points2circle(p1, p2, p3):    p1 = np.array(p1)    p2 = np.array(p2)    p3 = np.array(p3)    num1 = len(p1)    num2 = len(p2)    num3 = len(p3)    # 输入检查    if (num1 == num2) and (num2 == num3):        if num1 == 2:            p1 = np.append(p1, 0)            p2 = np.append(p2, 0)            p3 = np.append(p3, 0)        elif num1 != 3:            print('\t仅支持二维或三维坐标输入')            return None    else:        print('\t输入坐标的维数不一致')        return None    # 共线检查    temp01 = p1 - p2    temp02 = p3 - p2    temp03 = np.cross(temp01, temp02)    temp = (temp03 @ temp03) / (temp01 @ temp01) / (temp02 @ temp02)    if temp < 10**-6:        print('\t三点共线, 无法确定圆')        return None    temp1 = np.vstack((p1, p2, p3))    temp2 = np.ones(3).reshape(3, 1)    mat1 = np.hstack((temp1, temp2))  # size = 3x4    m = +det(mat1[:, 1:])    n = -det(np.delete(mat1, 1, axis=1))    p = +det(np.delete(mat1, 2, axis=1))    q = -det(temp1)    temp3 = np.array([p1 @ p1, p2 @ p2, p3 @ p3]).reshape(3, 1)    temp4 = np.hstack((temp3, mat1))    temp5 = np.array([2 * q, -m, -n, -p, 0])    mat2 = np.vstack((temp4, temp5))  # size = 4x5    A = +det(mat2[:, 1:])    B = -det(np.delete(mat2, 1, axis=1))    C = +det(np.delete(mat2, 2, axis=1))    D = -det(np.delete(mat2, 3, axis=1))    E = +det(mat2[:, :-1])    pc = -np.array([B, C, D]) / 2 / A    r = np.sqrt(B * B + C * C + D * D - 4 * A * E) / 2 / abs(A)    return pc, rdef calculate_distance(point_1, point_2):    dis_x = abs(point_1[0] - point_2[0])    dis_y = abs(point_1[1] - point_2[1])    distance = (dis_x ** 2 + dis_y ** 2) ** 0.5    return distancedef determine_point_in_circle(p, pc, r):    distance = calculate_distance(p, pc)    if distance < r:        return True    else:        return Falsedef find_left_and_right_point(point_1, point_2):    if point_1[0] < point_2[0]:        return point_1, point_2    elif point_1[0] > point_2[0]:        return point_2, point_1def find_center_point(keypoints):    assert len(keypoints) == 4    pc_0, r_0 = points2circle(keypoints[1], keypoints[2], keypoints[3])    pc_1, r_1 = points2circle(keypoints[0], keypoints[2], keypoints[3])    pc_2, r_2 = points2circle(keypoints[0], keypoints[1], keypoints[3])    pc_3, r_3 = points2circle(keypoints[0], keypoints[1], keypoints[2])    if determine_point_in_circle(keypoints[0], pc_0, r_0):        return 0    elif determine_point_in_circle(keypoints[1], pc_1, r_1):        return 1    elif determine_point_in_circle(keypoints[2], pc_2, r_2):        return 2    elif determine_point_in_circle(keypoints[3], pc_3, r_3):        return 3def get_two_point_center_point(p_1, p_2):    p = []    p.append((p_1[0] + p_2[0]) / 2)    p.append((p_1[1] + p_2[1]) / 2)    return pdef find_two_point_by_distance(c_point, center_id, keypoints):    keypoints.pop(center_id)    assert len(keypoints) == 3    id_list = [[0, 1], [0, 2], [1, 2]]    center_0_1 = get_two_point_center_point(keypoints[0], keypoints[1])    center_0_2 = get_two_point_center_point(keypoints[0], keypoints[2])    center_1_2 = get_two_point_center_point(keypoints[1], keypoints[2])    distance_c01_cp = calculate_distance(center_0_1, c_point)    distance_c02_cp = calculate_distance(center_0_2, c_point)    distance_c12_cp = calculate_distance(center_1_2, c_point)    distance_list = [distance_c01_cp, distance_c02_cp, distance_c12_cp]    sorted_id = sorted(range(len(distance_list)), key=lambda k: distance_list[k], reverse=True)    near_id = id_list[sorted_id[-1]]    return keypoints[near_id[0]], keypoints[near_id[1]]def find_two_points_by_angle(c_point, center_id, keypoints):    keypoints.pop(center_id)    assert len(keypoints) == 3    id_list = [[0, 1], [0, 2], [1, 2]]    angle_0_1 = angle(c_point + keypoints[0], c_point + keypoints[1])    angle_0_2 = angle(c_point + keypoints[0], c_point + keypoints[2])    angle_1_2 = angle(c_point + keypoints[1], c_point + keypoints[2])    angle_list = [angle_0_1, angle_0_2, angle_1_2]    sorted_id = sorted(range(len(angle_list)), key=lambda k: angle_list[k], reverse=True)    near_id = id_list[sorted_id[0]]    return keypoints[near_id[0]], keypoints[near_id[1]]def determine_direction(point_center, point):    center_x = point_center[0]    center_y = point_center[0]    x = point[0]    y = point[1]    if center_x < x and center_y > y:        return 'northeast'    elif center_x < x and center_y < y:        return 'southeast'    elif center_x > x and center_y < y:        return 'southwest'    elif center_x > x and center_y > y:        return 'northwest'def angle(v1, v2):    dx1 = v1[2] - v1[0]    dy1 = v1[3] - v1[1]    dx2 = v2[2] - v2[0]    dy2 = v2[3] - v2[1]    angle1 = math.atan2(dy1, dx1)    angle1 = float(angle1 * 180 / math.pi)    # print(angle1)    angle2 = math.atan2(dy2, dx2)    angle2 = float(angle2 * 180 / math.pi)    # print(angle2)    if angle1 * angle2 >= 0:        included_angle = abs(angle1 - angle2)    else:        included_angle = abs(angle1) + abs(angle2)        if included_angle > 180:            included_angle = 360 - included_angle    return included_angledef calculate_rotation_angle(keypoints):    # 判断四个点中哪个点位于三个点的中间    center_id = find_center_point(keypoints)    point_center = keypoints[center_id]    # 判断筒边缘的两个点    # the_one, the_other = find_two_point_by_distance(point_center, center_id, keypoints)    the_one, the_other = find_two_points_by_angle(point_center, center_id, keypoints)    point_left, point_right = find_left_and_right_point(the_one, the_other)    # 判断目前筒正前方朝向    point_mid = []    point_mid.append((point_left[0] + point_right[0]) / 2)    point_mid.append((point_left[1] + point_right[1]) / 2)    direction = determine_direction(point_center, point_mid)    if direction == 'northeast' or direction == 'northwest':        turn = 'clockwise'    elif direction == 'southeast' or direction == 'southwest':        turn = 'anticlockwise'    # print(point_left, point_right, sep='    ')    # 确定夹角，v1为y轴向量    v1 = [0.0, 0.0, 0.0, -1.0]    # v2 = point_left + point_right    if turn == 'clockwise':        v2 = point_right + point_left    elif turn == 'anticlockwise':        v2 = point_left + point_right    the_angle = angle(v1, v2)    return the_angle, turnif __name__ == '__main__':    the_id = '2'    re_dir = 'json_' + the_id    files = os.listdir(re_dir)    flag = 1    for file in files:        re_json_dir = os.path.join(re_dir, file)        with open(re_json_dir, 'r', encoding='utf8')as fp:            json_data = json.load(fp)            # print(json_data)            image_name = json_data['imagePath']            point_shapes = json_data['shapes']            key_points = []            for point in point_shapes:                key_points.append(point['points'][0])            print(image_name)            print(key_points)            turn_angle, turn_direction = calculate_rotation_angle(key_points)            print(turn_angle, turn_direction, sep='    ')            print('-----------------------------\n')            # write_line = image_name + ',' + str(turn_angle) + ',' + turn_direction            # f = open('image_angle.txt', 'a')            # if flag == 1:            #     f.write(str(write_line))            #     flag = 0            # f.write('\n' + str(write_line))            # f.close()